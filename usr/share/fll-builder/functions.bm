#!/bin/bash
# Common functions for fll-build(8)

LANG=C
LC_ALL=C
export LANG LC_ALL

chroot_exec() {
	# adapted from live-package
	chroot "$FLL_BUILD_CHROOT" /usr/bin/env -i \
		SHELL="$SHELL" \
		HOME="/root" \
		PATH="/usr/sbin:/usr/bin:/sbin:/bin" \
		DEBIAN_FRONTEND="noninteractive" \
		DEBIAN_PRIORITY="critical" \
		DEBCONF_NOWARNINGS="yes" \
		$@
	
	return $?
}

copy_to_chroot() {
	local ORIGFILE="$1"
	local DESTFILE="${FLL_BUILD_CHROOT}${1}"
	
	if [[ -f "$DESTFILE" ]]; then
		mv -v "$DESTFILE" "$DESTFILE".orig
	fi

	cp -v "$ORIGFILE" "$DESTFILE"
}

remove_from_chroot() {
	local FILE="${FLL_BUILD_CHROOT}${1}"
	
	rm -vf "$FILE"
	
	if [[ -f "$FILE".orig ]]; then
		mv -v "$FILE".orig "$FILE"
	fi
}

create_chroot_policy() {
	local POLICY="$FLL_BUILD_CHROOT"/usr/sbin/policy-rc.d
	
# disable all init scripts as per /usr/share/doc/sysv-rc/README.policy-rc.d.gz.
	cat > "$POLICY" \
<<EOF
#!/bin/sh

exit 101
EOF
	chmod 0755 "$POLICY"
}

create_interfaces() {
	local IFACES="$FLL_BUILD_CHROOT"/etc/network/interfaces
	
	cat > "$IFACES" \
<<EOF
# /etc/network/interfaces -- configuration file for ifup(8), ifdown(8)

# The loopback interface
# automatically added when upgrading
auto lo
iface lo inet loopback
EOF
}

create_debian_chroot() {
	local DEBCHROOT="$FLL_BUILD_CHROOT"/etc/debian_chroot

	cat > "$DEBCHROOT" \
<<EOF
$FLL_DISTRO_NAME-live
EOF
}

create_fstab() {
	local FSTAB="$FLL_BUILD_CHROOT"/etc/fstab
	
	cat > "$FSTAB" \
<<EOF
# /etc/fstab: static file system information.
#
# <file system>	<mount point>	<type>	<options>		<dump>	<pass>
EOF
}

create_hosts() {
	local HOSTS="$FLL_BUILD_CHROOT"/etc/hosts
	
	cat > "$HOSTS" \
<<EOF
127.0.0.1	localhost
127.0.0.1	$FLL_DISTRO_NAME

# The following lines are desirable for IPv6 capable hosts
# (added automatically by netbase upgrade)

::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
ff02::3 ip6-allhosts
EOF
}

create_sources_list() {
	local SOURCESLIST="$FLL_BUILD_CHROOT"/etc/apt/sources.list
	case $1 in
		working)
			cat > "$SOURCESLIST" \
<<EOF
deb $FLL_BUILD_DEBIANMIRROR sid main
#deb-src $FLL_BUILD_DEBIANMIRROR sid main

deb $FLL_BUILD_SIDUXMIRROR sid main fix.main
#deb-src $FLL_BUILD_SIDUXMIRROR sid main fix.main
EOF
			;;
		final)
			cat > "$SOURCESLIST" \
<<EOF
deb http://ftp.debian.org/debian/ sid main
deb-src http://ftp.debian.org/debian/ sid main

deb http://ftp.debian.org/debian/ testing main
deb-src http://ftp.debian.org/debian/ testing main

deb http://sidux.com/debian/ sid main fix.main
deb-src http://sidux.com/debian/ sid main fix.main
EOF
			;;
	esac
}

append_sudoers() {
	local SUDOERS="$FLL_BUILD_CHROOT"/etc/sudoers

	[[ -f "$SUDOERS" ]] || return 1

	cat >> "$SUDOERS" \
<<EOF

# WARNING: This allows the unprivileged $FLL_LIVE_USER user to start commands as root
# WARNING: This is totally insecure and (almost) makes $FLL_LIVE_USER a second root account.
# WARNING: Never allow external access to the $FLL_LIVE_USER user!!!
$FLL_LIVE_USER	ALL=NOPASSWD: ALL
EOF

	chmod 0440 "$SUDOERS"
}

create_kernelimg_conf() {
	local KERNELIMG="$FLL_BUILD_CHROOT"/etc/kernel-img.conf

	cat > "$KERNELIMG" \
<<EOF
do_symlinks = NO
do_bootloader = NO
warn_initrd = NO
ramdisk = mklive-initrd
EOF
}

install_linux_kernel() {
	local KZIP=$1 KTYPE KDIR KDEBS

	[[ $KZIP ]] || return 1

	case "$KZIP" in
		*.zip)
			if [[ -f $KZIP ]]; then
				KTYPE="file"
			else
				KTYPE="url"
			fi
			;;
		*)
			echo "Unrecognised kernel option: $KZIP"
			return 1
			;;
	esac

	KDIR=$(mktemp -p $FLL_BUILD_CHROOT -d kernel.XXXX)

	# cannot pushd here, it breaks relative kernel paths
	case "$KTYPE" in
		"file")
			cp "$KZIP" "$KDIR"/kernel.zip
			;;
		"url")
			wget -N -T10 "$KZIP" -O "$KDIR"/kernel.zip
			;;
	esac

	pushd "$KDIR" >/dev/null
		if unzip kernel.zip; then
			find . -maxdepth 1 -type f ! -name '*.deb' -exec rm -vf {} \;
			apt-ftparchive packages . > Packages
		fi
	
	popd >/dev/null

	if [[ -f $KDIR/Packages ]]; then
		KDEBS=$(sed -n 's/^Package: \(.\+\)/\1/p' $KDIR/Packages)
		[[ $KDEBS ]] || return 1
	fi

	# XXX: hack until new package is uploaded
	copy_to_chroot /usr/sbin/mklive-initrd
	
	# ask kernel package nicely to create a miniroot for our kernel
	create_kernelimg_conf

	echo "deb file://${KDIR//$FLL_BUILD_CHROOT/} ./" >> "$FLL_BUILD_CHROOT"/etc/apt/sources.list
	
	chroot_exec apt-get update
	chroot_exec apt-get --allow-unauthenticated --assume-yes install "$KDEBS"

	for kernel in "$FLL_BUILD_CHROOT"/boot/vmlinuz-*; do
		[[ -f $kernel ]] || continue
		kernel=$(sed 's/.*vmlinuz-//' <<< $kernel)
		# fix up kernel links
		chroot_exec rm -vf /lib/modules/$kernel/build /lib/modules/$kernel/source
		chroot_exec ln -vs linux-headers-$kernel /usr/src/linux-$kernel
		chroot_exec ln -vs /usr/src/linux-$kernel /lib/modules/$kernel/build
		chroot_exec ln -vs /usr/src/linux-$kernel /lib/modules/$kernel/source
		chroot_exec cp -vf /boot/config-$kernel /usr/src/linux-$kernel/.config
		chroot_exec rm -rf /usr/src/linux-$kernel/Documentation
		chroot_exec ln -vs /usr/share/doc/linux-doc-$kernel/Documentation \
			/usr/src/linux-$kernel/Documentation
		chroot_exec ln -vs vmlinuz-$kernel /boot/vmlinuz
		chroot_exec ln -vs initrd.img-$kernel /boot/miniroot.gz
	done

	rm -rf "$KDIR"
}

# XXX: TODO
make_compressed_image() {
	mksquashfs "$FLL_BUILD_CHROOT" "$FLL_BUILD_RESULT"/"$FLL_IMAGE_LOCATION" -info 
}

make_fll_iso() {
	genisoimage \
		-pad -l -r -J -v -V \"$FLL_DISTRO_NAME\" -no-emul-boot -boot-load-size 4 \
		-boot-info-table -b boot/grub/iso9660_stage1_5 -c boot/grub/boot.cat -hide-rr-moved \
		-o "$FLL_BUILD_ISO_OUTPUT" "$FLL_BUILD_RESULT"
}
# END TODO

virtfs() {
	local ACTION=$1 PROC=$2

	[[ $ACTION && -d $PROC ]] || return 1

	case "$ACTION" in
		mount)
			mount  procfll -t proc "$PROC"
			;;
		umount)
			grep -q "$PROC" /proc/mounts || return 0
			umount "$PROC"
			;;
	esac

	return $?
}

nuke_buildarea() {
	[[ -d $FLL_BUILD_AREA ]] || return 0

	if virtfs umount "$FLL_BUILD_CHROOT"/proc; then
		if [[ $FLL_BUILD_PRESERVE_CHROOT ]]; then
			echo "Chroot preserved at $FLL_BUILD_AREA"
			return 0
		fi
		# adpated from pbuilder
		find "$FLL_BUILD_AREA" -xdev \( \! -type d \) -print0 | xargs -0 rm -f
  		find "$FLL_BUILD_AREA" -xdev -depth -type d -print0 | xargs -0 rmdir
	else
		echo "Error umounting virtual filesystems"
		echo "You must manually cleanup up $FLL_BUILD_AREA"
	fi
}
