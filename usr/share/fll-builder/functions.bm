#!/bin/bash
# Common functions for fll-build(8)

LANG=C
LC_ALL=C
export LANG LC_ALL

chroot_exec() {
	# adapted from live-package
	chroot "$FLL_BUILD_CHROOT" /usr/bin/env -i \
		SHELL="$SHELL" \
		HOME="/root" \
		PATH="/usr/sbin:/usr/bin:/sbin:/bin" \
		DEBIAN_FRONTEND="noninteractive" \
		DEBIAN_PRIORITY="critical" \
		DEBCONF_NOWARNINGS="yes" \
		$@
	
	return $?
}

copy_to_chroot() {
	local ORIGFILE="$1"
	local DESTFILE="${FLL_BUILD_CHROOT}${1}"
	
	if [[ -f "$DESTFILE" ]]; then
		mv -v "$DESTFILE" "$DESTFILE".orig
	fi

	cp -v "$ORIGFILE" "$DESTFILE"
}

remove_from_chroot() {
	local OBJ="${FLL_BUILD_CHROOT}${1}"

	rm -vf $OBJ
	
	if [[ -e "$OBJ".orig ]]; then
		mv -v "$OBJ".orig "$OBJ"
	fi
}

exists_in_chroot() {
	local OBJ="${FLL_BUILD_CHROOT}${1}"

	if [[ -e $OBJ ]]; then
		return 0
	fi

	return 1
}

cat_file() {
	local FILE="$1"
	local DEST="$2"

	[[ $1 && $2 ]] || return 1

	echo "Creating \`$FILE' at $DEST"

	case "$FILE" in

		apt_conf)
			if [[ $FLL_HTTP_PROXY ]]; then
				cat > "$DEST" \
<<EOF
Acquire::http::Proxy "$FLL_HTTP_PROXY";
EOF
			elif [[ $FLL_FTP_PROXY ]]; then
				cat > "$DEST" \
<<EOF
Acquire::ftp::Proxy "$FLL_FTP_PROXY";
EOF
			fi
			;;

		apt_sources)
			cat > "$DEST" \
<<EOF
deb http://ftp.debian.org/debian/ sid main
deb-src http://ftp.debian.org/debian/ sid main

deb http://ftp.debian.org/debian/ testing main
deb-src http://ftp.debian.org/debian/ testing main

deb http://sidux.com/debian/ sid main fix.main
deb-src http://sidux.com/debian/ sid main fix.main
EOF
			;;

		apt_sources_tmp)
			cat > "$DEST" \
<<EOF
deb $FLL_BUILD_DEBIANMIRROR sid main
deb-src $FLL_BUILD_DEBIANMIRROR sid main

deb $FLL_BUILD_FLLMIRROR sid main fix.main
deb-src $FLL_BUILD_FLLMIRROR sid main fix.main
EOF
			;;

		chroot_policy)
			cat > "$DEST" \
<<EOF
#!/bin/sh
# disable init scripts: /usr/share/doc/sysv-rc/README.policy-rc.d.gz

exit 101
EOF
			chmod 0755 "$DEST"
			;;

		debian_chroot)
			cat > "$DEST" \
<<EOF
$FLL_DISTRO_NAME-live
EOF
			;;

		fstab)
			cat > "$DEST" \
<<EOF
# /etc/fstab: static file system information.
#
# <file system>	<mount point>	<type>	<options>		<dump>	<pass>
EOF
			;;

		hosts)
			cat > "$DEST" \
<<EOF
127.0.0.1	localhost
127.0.0.1	$FLL_DISTRO_NAME

# The following lines are desirable for IPv6 capable hosts
# (added automatically by netbase upgrade)

::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
ff02::3 ip6-allhosts
EOF
			;;

		interfaces)
			cat > "$DEST" \
<<EOF
# /etc/network/interfaces -- configuration file for ifup(8), ifdown(8)

# The loopback interface
# automatically added when upgrading
auto lo
iface lo inet loopback
EOF
			;;

		kernelimg)
			cat > "$DEST" \
<<EOF
do_symlinks = NO
do_bootloader = NO
warn_initrd = NO
ramdisk = mklive-initrd
EOF
			;;

		sort_iso)
			cat > "$DEST" \
<<EOF
$FLL_BUILD_RESULT/boot/grub/* 111111
$FLL_BUILD_RESULT/boot/* 111110
${FLL_BUILD_RESULT}${FLL_MOUNTPOINT} 100001
EOF
			;;

		sudoers)
			[[ -f "$DEST" ]] || return 1
			# append
			cat >> "$DEST" \
<<EOF

# WARNING: This allows the unprivileged $FLL_LIVE_USER user to start commands as root
# WARNING: This is totally insecure and (almost) makes $FLL_LIVE_USER a second root account.
# WARNING: Never allow external access to the $FLL_LIVE_USER user!!!
$FLL_LIVE_USER	ALL=NOPASSWD: ALL
EOF
			
			chmod 0440 "$DEST"
			;;

esac
}

install_debs_from_dir() {
	local DEBDIR="$1"
	local CHROOTDEBDIR="${DEBDIR//$FLL_BUILD_CHROOT/}"
	local DEBS

	[[ -d $DEBDIR ]] || return 1

	pushd "$DEBDIR" >/dev/null
		apt-ftparchive packages . > Packages
	popd >/dev/null

	if [[ -s $DEBDIR/Packages ]]; then
		DEBS=( $(awk '/^Package: /{ print $2 }' $DEBDIR/Packages) )
		if [[ -z ${DEBS[@]} ]]; then
			return 1
		fi
	else
		return 1
	fi

	cat_file apt_sources_tmp "$FLL_BUILD_CHROOT"/etc/apt/sources.list

	echo "deb file://$CHROOTDEBDIR ./" \
		>> "$FLL_BUILD_CHROOT"/etc/apt/sources.list

	chroot_exec apt-get update
	chroot_exec apt-get --allow-unauthenticated --assume-yes install ${DEBS[@]}

	return $?
}

install_linux_kernel() {
	local KZIP="$1"
	local KDIR=$(mktemp -p $FLL_BUILD_CHROOT -d kernel.XXXX)
	local KTYPE KDEBS KURL

	[[ $KZIP ]] || return 1

	case "$KZIP" in
		*kernel-*.zip)
			[[ -f $KZIP ]] && KTYPE="file" || KTYPE="url"
			;;
		*)
			echo "Unrecognised kernel option: $KZIP"
			return 1
			;;
	esac

	# use bash regexp to determine kernel version
	if [[ $KZIP =~ '.*/kernel-(.*).zip' ]]; then
		if [[ $DEBUG ]]; then
			for ((i=0; i<${#BASH_REMATCH[@]}; i++)); do
               			echo "\${BASH_REMATCH[$i]} => ${BASH_REMATCH[$i]}"
        		done
		fi
		KVERS=${BASH_REMATCH[1]}
		# package list needs to filter these packages out :(
		export KVERS
	fi

	# cannot pushd here, it breaks relative kernel paths
	case "$KTYPE" in
		"file")
			cp "$KZIP" "$KDIR"/kernel-"$KVERS".zip
			;;
		"url")
			wget -T3 "$KZIP" -O "$KDIR"/kernel-"$KVERS".zip
			;;
	esac

	pushd "$KDIR" >/dev/null
		unzip kernel-"$KVERS".zip
	popd >/dev/null

	install_debs_from_dir "$KDIR"

	chroot_exec rm -vf /lib/modules/"$KVERS"/build /lib/modules/"$KVERS"/source
	chroot_exec ln -vs linux-headers-"$KVERS" /usr/src/linux-"$KVERS"
	chroot_exec ln -vs /usr/src/linux-"$KVERS" /lib/modules/"$KVERS"/build
	chroot_exec ln -vs /usr/src/linux-"$KVERS" /lib/modules/"$KVERS"/source
	chroot_exec cp -vf /boot/config-"$KVERS" /usr/src/linux-"$KVERS"/.config
	chroot_exec rm -rf /usr/src/linux-"$KVERS"/Documentation
	chroot_exec ln -vs /usr/share/doc/linux-doc-"$KVERS"/Documentation \
		/usr/src/linux-"$KVERS"/Documentation
	chroot_exec ln -vs vmlinuz-"$KVERS" /boot/vmlinuz
	chroot_exec ln -vs initrd.img-"$KVERS" /boot/miniroot.gz
	
	# save kernel.zip if building source iso
	if [[ $FLL_BUILD_SOURCE_REL ]]; then
		# XXX: what about linux + modules source code?
		cp -v "$KDIR"/kernel-"$KVERS".zip "$FLL_BUILD_SOURCE"/kernel/kernel-"$KVERS".zip
	fi

	rm -vrf "$KDIR"
}

make_compressed_image() {
	local SQUASHFSEXCLUDELIST=$(mktemp -p $FLL_BUILD_AREA squashfs-list.XXXXX)
	local SQUASHFSEXCLUDEFILE=$(mktemp -p $FLL_BUILD_AREA squashfs-exclude.XXXXX)
	local MKSQUASHFSOPTS="-ef $SQUASHFSEXCLUDEFILE"
	
	# XXX: TODO
	# XXX: we need an input exclusions list with wildcards to be
	# expanded by some magic and written to the final sort file.
	cat > "$SQUASHFSEXCLUDEFILE" \
<<EOF
.bash_history
EOF

	if [[ -s $FLL_BUILD_SQUASHFS_SORTFILE ]]; then
		MKSQUASHFSOPTS="$MKSQUASHFSOPTS -sort $FLL_BUILD_SQUASHFS_SORTFILE"
	fi

	pushd "$FLL_BUILD_CHROOT" >/dev/null
		mksquashfs . "$FLL_BUILD_RESULT"/"$FLL_IMAGE_LOCATION" $MKSQUASHFSOPTS
	popd >/dev/null
}

make_fll_iso() {
	local ISOSORTLIST=$(mktemp -p $FLL_BUILD_AREA sortlist.XXXXX)

	cat_file sort_iso "$ISOSORTLIST"

	# set default ISO name
	case $DEBOOTSTRAP_ARCH in
		i?86)
			FLL_ISO_NAME="$(tr a-z A-Z <<< ${FLL_DISTRO_NAME}-${FLL_DISTRO_VERSION}-${FLL_DISTRO_CODENAME}-${PACKAGE_TIMESTAMP}\.ISO)"
			FLL_SOURCE_ISO_NAME="$(tr a-z A-Z <<< ${FLL_DISTRO_NAME}-${FLL_DISTRO_VERSION}-${FLL_DISTRO_CODENAME}-${PACKAGE_TIMESTAMP}\.SOURCE\.ISO)"
			;;
		amd64|x86_64)
			FLL_ISO_NAME="$(tr a-z A-Z <<< ${FLL_DISTRO_NAME}64-${FLL_DISTRO_VERSION}-${FLL_DISTRO_CODENAME}-${PACKAGE_TIMESTAMP}\.ISO)"
			FLL_SOURCE_ISO_NAME="$(tr a-z A-Z <<< ${FLL_DISTRO_NAME}64-${FLL_DISTRO_VERSION}-${FLL_DISTRO_CODENAME}-${PACKAGE_TIMESTAMP}\.SOURCE\.ISO)"
			;;
		*)
			FLL_ISO_NAME="$(tr a-z A-Z <<< ${FLL_DISTRO_NAME}-${DEBOOTSTRAP_ARCH}-${FLL_DISTRO_VERSION}-${FLL_DISTRO_CODENAME}-${PACKAGE_TIMESTAMP}\.ISO)"
			FLL_SOURCE_ISO_NAME="$(tr a-z A-Z <<< ${FLL_DISTRO_NAME}-${DEBOOTSTRAP_ARCH}-${FLL_DISTRO_VERSION}-${FLL_DISTRO_CODENAME}-${PACKAGE_TIMESTAMP}\.SOURCE\.ISO)"
			;;
	esac

	# make the iso
	genisoimage -v -pad -l -r -J \
		-V "$FLL_DISTRO_NAME_UC" \
		-A "$FLL_DISTRO_NAME_UC LIVE LINUX CD" \
		-no-emul-boot -boot-load-size 4 -boot-info-table \
		-b boot/grub/iso9660_stage1_5 -c boot/grub/boot.cat \
		-hide-rr-moved \
		-sort "$ISOSORTLIST" \
		-o "$FLL_BUILD_ISO_OUTPUT"/"$FLL_ISO_NAME" \
		"$FLL_BUILD_RESULT"
	
	# generate md5sums
	pushd "$FLL_BUILD_ISO_OUTPUT" >/dev/null
		md5sum -b "$FLL_ISO_NAME" > "$FLL_ISO_NAME".MD5
	popd >/dev/null
	
	# if started as user, apply user ownership to output (based on --uid)
	if [[ $FLL_BUILD_OUTPUT_UID != 0 ]]; then
		chown "$FLL_BUILD_OUTPUT_UID":"$FLL_BUILD_OUTPUT_UID" \
			"$FLL_BUILD_ISO_OUTPUT"/"$FLL_ISO_NAME"*
	fi
}

fetch_source_code() {
	# download source packages used in ISO creation
	# dump into $FLL_BUILD_SOURCE/{source,kernel}
	local PKGLIST=$(mktemp -p $FLL_BUILD_CHROOT pkglist.XXXX)
	local CHROOTPKGLIST="${PKGLIST//$FLL_BUILD_CHROOT/}"
	local SOURCE LETTER
	
	# ensure we are working with clean sources.list (install_linux_kernel() "taints" it)
	cat_file apt_sources_tmp "$FLL_BUILD_CHROOT"/etc/apt/sources.list
	
	# XXX: some packages mysteriously fail to download when =version is suffixed
	# chroot_exec COLUMNS=250 dpkg --list | awk -v kvers=$KVERS \
	#	'/^[hi]i/{ if($2 !~ kvers) { printf("%s=%s\n", $2, $3) }}' > "$CHROOTPKGLIST"
	
	# XXX: damned kernel packages have no source, filter KVERS
	chroot_exec COLUMNS=250 dpkg --list | awk -v kvers=$KVERS \
		'/^[hi]i/{ if($2 !~ kvers) { print $2 }}' > "$CHROOTPKGLIST"
	
	chroot_exec apt-get source --download-only $(< $CHROOTPKGLIST)
	# XXX: uncomment this one fll-builder has been packaged
	#chroot_exec apt-get source --download-only fll-builder

	# sort sources (adapted from live-package)
	for dsc in "$FLL_BUILD_CHROOT"/*.dsc; do
		SOURCE=$(awk '/Source:/ { print $2 }' $dsc)
 
 		[[ ${SOURCE:0:3} == lib ]] && LETTER=${SOURCE:0:4} || LETTER=${SOURCE:0:1}
 
 		mkdir -vp "$FLL_BUILD_SOURCE"/source/"$LETTER"/"$SOURCE"
 
 		# Move sources
 		mv -v "$FLL_BUILD_CHROOT"/"$SOURCE"_* "$FLL_BUILD_SOURCE"/source/"$LETTER"/"$SOURCE"
 	done

	rm -vf "$PKGLIST"

	# create trivial repository index
	# XXX: improve me
	pushd "${FLL_BUILD_SOURCE}/source/" >/dev/null
		apt-ftparchive sources . > Sources
		gzip  -c Sources > Sources.gz
		bzip2 -c Sources > Sources.bz2
	popd >/dev/null
}

make_fll_source_iso() {
	# make the iso
	genisoimage -v -pad -l -r -J \
		-V "${FLL_DISTRO_NAME_UC}-SOURCE" \
		-A "$FLL_DISTRO_NAME_UC LIVE LINUX CD SOURCE" \
		-hide-rr-moved \
		-o "${FLL_BUILD_ISO_OUTPUT}/${FLL_SOURCE_ISO_NAME}" \
		"${FLL_BUILD_SOURCE}/source/"
	
	# generate md5sums
	pushd "$FLL_BUILD_ISO_OUTPUT" >/dev/null
		md5sum -b "$FLL_SOURCE_ISO_NAME" > "${FLL_SOURCE_ISO_NAME}.MD5"
	popd >/dev/null
	
	# if started as user, apply user ownership to output (based on --uid)
	if [[ $FLL_BUILD_OUTPUT_UID != 0 ]]; then
		chown "$FLL_BUILD_OUTPUT_UID":"$FLL_BUILD_OUTPUT_UID" \
			"${FLL_BUILD_ISO_OUTPUT}/${FLL_SOURCE_ISO_NAME}*"
	fi
}

virtfs() {
	local ACTION="$1"
	local PROC="$FLL_BUILD_CHROOT"/proc

	[[ $ACTION && $PROC ]] || return 1
	[[ -d $PROC ]] || return 0

	case "$ACTION" in
		mount)
			mount  procfll -t proc "$PROC"
			;;
		umount)
			grep -q "$PROC" /proc/mounts || return 0
			umount "$PROC"
			;;
	esac

	return $?
}

nuke_buildarea() {
	[[ -d $FLL_BUILD_AREA ]] || return 0

	if virtfs umount; then
		if [[ $FLL_BUILD_PRESERVE_CHROOT ]]; then
			echo "Chroot preserved at $FLL_BUILD_AREA"
			return 0
		fi
		# adpated from pbuilder
		find "$FLL_BUILD_AREA" -xdev \( \! -type d \) -print0 | xargs -0 rm -f
  		find "$FLL_BUILD_AREA" -xdev -depth -type d -print0 | xargs -0 rmdir
		return 0
	else
		echo "Error umounting virtual filesystems"
		echo "You must manually cleanup up $FLL_BUILD_AREA"
		return 1
	fi
}
